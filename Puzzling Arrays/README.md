Spencer Fletcher
sfletch9@u.rochester.edu

My program is a finished project, it does what the problem statement asks without any bugs in it that I was able to find. Class Puzzle contains my main method.

There are 7 main functions that my program uses. The program starts with getting the user's desired mode, where if they input I, it goes into interactive mode and if they input V, it goes into validation mode.

If the user selects I, then the program calls the interact function of the interact class. Then the program prompts the user for a difficulty (1: Easy, 2: Medium, 3: Hard). It then multiplies their choice by a static number (currently 10) to obtain the number of random moves it will make to the base puzzle to obtain a randomized solvable solution, thus linearly increasing the difficulty based on the user's desired difficulty. The program then initializes the position of "zero" (the blank square) by calling the setZeroPos function. This function loops through the active grid until zero is found, and then sets a static variable zeroPos to the coordinates of zero. This function assumes that there exists a zero in the grid and that there is only one zero in the grid, both of which are valid assumptions. Once zero is initialized, the grid is generated with a call to the generateGrid function. This function takes an input of amountOfMoves, which was set earlier when the user was asked for a difficulty setting, and then randomly moves 0 around the standard grid (zero at top left) amountOfMoves times. This function is enclosed in a while loop that checks if the move was invalid and continues running the while loop until a valid move is made. This is to minimize the possibility of the grid being identical to the starting grid, or very similar. There is still a small chance of the grid being identical to the starting grid, and thus having the player win instantly, but this is unlikely to happen, especially with the preventative measure taken. The new generated grid is then printed so that the user can see it.

Then, the program enters its main loop for the interactive section. This loop will continue running until the player has managed to move the grid into either the original configuration of a zero at the top left and then numbers 1-15 in order left to right, top to bottom, or the configuration of a zero at the bottom right after the numbers 1-15 in order left to right, top to bottom. This loop first prompts the user to enter a move, then gets what the user inputs as a string.

The program uses this input to call the moveInDirection function, which takes two parameters: a String direction telling the function which direction to move in, and a boolean printError, which tells the function whether to print to console if there is an error with the program (this is needed for verification mode, where the intended behavior is to not output to console if there is an error). Direction in this case takes the user's input as a string, and printError is always true, as we want the user to know whether the move they made was valid.

Once the moveInDirection function is called, it first creates a new array with size 2 to be used as coordinates to store what item to swap zero with. It then enters a switch statement. Case "U" attempts to move zero upwards, if zero is already in the top row it returns without executing anything, unless printError is true, in which case it prints "That is an invalid move." to console and then returns. If zero is not already in the top row (i.e., it can be moved) the function gets the y-coordinate of the item above 0 using zeroPos' y position minus 1, and uses the same x position as zeroPos, as zero only needs to be moved upwards. Then, the function swap is called with the input of the coordinates of the item to swap. swap simply swaps zero with the item at itemToSwap's coordinates it was passed when it was called. This is done by setting the item at zero's current position in the grid to the item at itemToSwap's coordinates, and then setting the item at itemToSwap's coordinates to 0. zeroPos is then updated with its new position. The other items in the switch statement work much the same way. A directional input of "R" moves zero to the right, unless zero is all the way to the right already. A directional input of "D" moves zero downwards, unless zero is all the way down already. A directional input of "L" moves zero leftwards, unless zero is all the way to the left already. Any input other than "U", "R", "D", or "L" goes to the switch statement's default case, which prints "Invalid input" to the console and returns -1 from the function. Whether the move was valid or not, the grid is reprinted, updated if a valid move was made, the same as the previous print if the move was invalid.

This pattern of input to movement based on input to reprint will continue indefinitely until the board is solved. Once the board is solved, the program exits the main loop, prints “Congrats! You solved the puzzle.” to console, and exits.

The Validate class works much the same way, just with only two user inputs to parse instead of possibly infinite inputs. To enter the Validate class, the user inputs V instead of I when prompted to select the mode.

The first thing that happens in validation mode is that the user is prompted for their modified table to verify the move sequence for, using the getTable function. In the getTable function, the user enters their table one row at a time, with spaces separating the 4 items. These items are then added to the activeGrid. Then, zero is found in the activeGrid using the setZeroPos function, and then the activeGrid is printed. The user is then prompted for their move sequence (e.g., URLDU). Then, the program loops through the string of letters one character at a time, calling the moveInDirection function with each character, not printing to console if the move is invalid. The program then prints the grid after moves to the console and checks if the grid after moves is equal to one of the valid solution grids. If it is, then it prints “Your move sequence was correct!”. If not, it prints “Your move sequence was incorrect”. Either way, after the user is informed whether their solution was correct, the program ends.
