Spencer Fletcher - sfletch9@u.rochester.edu - 32135435
Jacob Trokel - jtrokel@u.rochester.edu - 32091663
Stephanie Kim - skim296@u.rochester.edu - 31980692

In order to play our game, you run the main function in the GameManager class.

We made a Doodle Jump-esque platforming game where you can collect coins and there are 2 levels to beat. The animation in our game comes in the form of the player moving around. The interaction is the same: you use the arrow keys to move the player left and right and to jump. The scoring mechanism is lives that the player can lose if he falls off the screen, and the coins he can collect. The definitive ending mechanism is a goal at the end of the second level where
you win, and you can lose if you run out of lives. The physical mechanism is gravity and velocity implemented for the player, collision detection is the player on the floor, hitting coins, hitting spikes, and hitting the goal. We came up with the idea after working on a regular platformer and deciding it was not interesting enough, so we changed how it worked a bit. The flourish we added is generating random spike locations.

Our project has 9 classes. The first class, Block, is a class for the floor, and it is just a constructor and a draw method. It also has an overloaded constructor for special platforms (spawn and goal platforms). It extends another class, Sprite. Goal is essentially the same as Block, and so is Spike, but without the overloaded constructor. Spike also draws a triangle instead of a rectangle. Coin also extends Sprite, but has both a draw method and a collect method. The collect method adds to the coin count and removes the coin from the sprite list so it's no longer rendered. Sprite has a constructor which gives the sprite dimensions and adds it to an ArrayList of sprites to be drawn each frame in PaintComponent unless the sprite is a player, because the player would collide with itself if it was in the Sprites ArrayList. It also has an enum with the different types of sprites included in our game. Player is the last class that extends Sprite, and it is more complex. It has methods bottomIntersects, which is used to see if the bottom of the player is on a floor, the method move, which changes the dx for the player, the method jump, which changes dy and handles double jumps, the method draw to draw it, the method resetPos to move it back to the start, and the method doPhysics. doPhysics is called every frame, and handles gravity, movement based on current dx and dy, and collision detection. Collision detection is done by checking if the player is colliding with anything every frame, and if it is add the collision to an ArrayList, then iterate through the ArrayList to see what it's colliding with and do something different depending on what it's hitting. Spike kills the player, Goal ends the level or the game, Coin collects the collided coin, and Floor stops the player from falling. The class CsvReader reads through a csv file with our level data on it, and depending on what value is in each box, it draws either a floor, a coin, a goal, or nothing there in the JFrame. It does this by iterating through the csv and drawing an object on the screen based on how far the loop has gotten. CollisionEvent has a constructor which makes sure a collision happened, and a method hasCollision to see if a collision has occurred. The player class also has a killPlayer method which resets the position of the player and subtracts a life.

The last class, GameManager, is the main class, and the most complex. It has a constructor, which sets up the window, creates the player object, and loads the level using the method loadLevel. The main method just makes a new GameManager using getInstance, and getInstance makes sure only one GameManager exists. loadLevel constructs the level from the csv file, then generates random spikes using the method generateRandomSpikes. generateRandomSpikes iterates through a list of all the floors and puts a spike on a tile using random number generators as well as making sure no two spikes are right next to each other. It also makes sure no spikes are placed on the spawn or goal platforms. The methods endLevel and endGame are called when the player hits the goal in level 1 or level 2 respectively. endLevel resets the player's position, clears the sprite list, and draws the next level, and endGame sets a variable ended to false. GameManager has an inner class MainPanel which extends JFrame and implements ActionListener and KeyListener. The constructor for MainPanel starts an animation timer and adds a key listener to the panel. It has two methods getHeart and getCoin which return a PNG image of a coin and a heart to be used in the lives and coins counters. It has an actionPerformed method which repaints every time something happens, and keyPressed and keyReleased methods which make the player start moving and stop moving. Finally, it has a paintComponent method, which is called every frame. It starts by loading the heart and coin images if they haven't been loaded yet, then draws the hearts, the coin counter, and the level counter depending on how many coins you have, hearts you have, and what level you're on. Then, it check if the player is past the sides of the screen, in which case they wrap around, and checks if the player is below the screen, in which case they die. It then does physics for the player, draws the player, and draws every sprite in the sprite list. Then, if the variable ended is true, it draws the you win screen, and if the player has less than 0 lives, it draws the you lose screen.

Essentially, our game runs like this: you start the game, it loads in any images it needs and the level file, it draws the level using a csv sheet with numbers corresponding to what sprite we want there, and it draws the player and any sprites. It then randomly generates spikes on any platform that isn't a special platform (spawn platform or goal platform). All the sprites are drawn using draw methods in their classes, which draw them how we wanted them to look. After that, we listen for a keypress each frame and change a dy or dx variable (the player's velocity) if we try to move. The player's position is then updated based on their horizontal and vertical velocities, as well as gravity. We also check each frame if the player is colliding with anything, then do something if they are. If they're colliding with a floor, we stop them from falling any further, if they're colliding with a coin, we collect that coin and make it invisible, if they're colliding with a goal, we either end the level or end the game, and if they're colliding with a spike, we reset their position and subtract a life. Lastly, every frame, we screenwrap the player if they're too far to one side or kill them if they're too low.